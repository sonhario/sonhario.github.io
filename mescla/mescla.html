<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Três Modos Alternáveis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: none;
        }
        
        .mode-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26,26,46,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
            z-index: 1000;
            font-family: 'Courier New', monospace;
        }

        .mode-indicator2 {
            position: fixed;
            top: 60px;
            right: 20px;
            background: rgba(26,26,46,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
            z-index: 1000;
            font-family: 'Courier New', monospace;
        }

        .mode-indicator3 {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(26,26,46,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
            z-index: 1000;
            font-family: 'Courier New', monospace;
        }
        
        .debug-info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(255,255,255,0.1);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 10px;
            z-index: 1000;
            font-family: 'Courier New', monospace;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            font-family: 'Courier New', monospace;
        }

        .loading-progress {
            margin-top: 20px;
            font-size: 14px;
        }

        .error-message {
            color: #ff6b6b;
            margin-top: 10px;
            text-align: center;
            max-width: 80%;
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <h2>Carregando...</h2>
        <div class="loading-progress" id="loadingProgress">Inicializando...</div>
        <div class="error-message" id="errorMessage"></div>
    </div>

    <div class="mode-indicator" id="modeIndicator">[caderno / diagramas] > X</div>
    <div class="mode-indicator2" id="modeIndicator2">[sonhos] > S / M </div>
    <div class="mode-indicator3" id="modeIndicator3">[sons] > A </div>
    <div class="debug-info" id="debugInfo">Debug: Carregando...</div>
    
    <script>
        // ===========================================
        // SISTEMA DE CARREGAMENTO E DEBUG
        // ===========================================
        let loadingComplete = false;
        let loadingErrors = [];

        function showError(message) {
            console.error(message);
            loadingErrors.push(message);
            updateLoadingScreen();
        }

        function updateLoadingScreen() {
            const progressDiv = document.getElementById('loadingProgress');
            const errorDiv = document.getElementById('errorMessage');
            
            if (progressDiv) {
                if (loadingComplete) {
                    progressDiv.textContent = 'Carregamento completo! Iniciando...';
                } else {
                    progressDiv.textContent = `Carregando: ${imagesLoaded}/${totalImages} imagens, ${soundsLoaded}/${totalSounds} sons`;
                }
            }
            
            if (errorDiv && loadingErrors.length > 0) {
                errorDiv.innerHTML = loadingErrors.join('<br>');
            }
        }

        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
        }

        // ===========================================
        // SISTEMA DE ALTERNÂNCIA ENTRE MODOS
        // ===========================================
        let currentAppMode = 'palavras'; // Mudei para começar com palavras, que sempre funciona
        
        // ===========================================
        // VARIÁVEIS DO MODO SLIDESHOW
        // ===========================================
        const imageFiles = [
            '1.jpg', '2.jpg', '3.jpg', '4.jpg', '5.jpg', '6.jpg', '7.jpg', '8.jpg', '9.jpg', '10.jpg',
            '11.jpg', '12.jpg', '13.jpg', '14.jpg', '15.jpg', '16.jpg', '17.jpg', '18.jpg', '19.jpg', '20.jpg',
            '21.jpg', '22.jpg', '23.jpg', '24.jpg', '25.jpg', '26.jpg'
        ];
        
        let images = [];
        let loadedImages = {};
        let currentImage = null;
        let currentCrop = null;
        let nextChangeTime = 0;
        let imagesLoaded = 0;
        let totalImages = imageFiles.length;
        let imageLoadErrors = 0;
        
        // ===========================================
        // VARIÁVEIS DO MODO PALAVRAS
        // ===========================================
        let conceptBoxes = [];
        let centerBox;
        let canvasWidth, canvasHeight;
        let RanDist = 50;
        let lastRanDistChange = 0;
        let ranDistChangeInterval = 5000;
        
        // Variáveis para mobile
        let isMobile = false;
        let virtualMouseX, virtualMouseY;
        let targetX, targetY;
        let currentSpeed = 0.01;
        let targetSpeed = 0.01;
        let lastSpeedChange = 0;
        let speedChangeInterval = 5000;
        let wanderAngle = 0;
        let wanderSpeed = 0.008;

        // Sistema de alternância entre modos de palavras
        let currentMode = 'attraction';
        let lastModeChange = 0;
        let modeChangeInterval = 10000;
        let transitionDuration = 2000;
        let isTransitioning = false;
        let transitionStartTime = 0;

        // Lista de conceitos
        const allConcepts = [
            "inteligência", "artificial", "não-fisiológico", "fisiológico", "sensorial", "racional",
            "conceito", "ontologia", "episteme", "consciente", "não-consciente", "arquivo",
            "memória", "arte", "especulação","sensível","reinventar","produzir",
            "tempo","anacronia","assombra","vestígio","bio","tecno","não-bio","não-tecno",
            "conjurar","extinção","continuidade","gaia","aceleração","problema",
            "ficar-com","vida","morte","atemporal","registro","relato","experiência",
            "pensamento","fóssil","confronto","transformação","invenção","onde","local","global",
            "plantar","anomia","ruído","inferência","real","não-real","abstração","causa",
            "efeito","afeto","ciência","objeto","malha","teia","sequência","aleatório","singular",
            "objetivo","subjetivo","resíduo","durante","antes","depois","presença","ausência",
            "sentidos","público","partitura","matemática","aqui","lá","ali","fronteira","espécie",
            "interespécie","dobra","finito","não-finito","escala","vazio","não-vazio",
            "espectralismo", "espectros", "perspectivismo", "anástrofe", "catástrofe", 
            "presságio", "fabulação", "fora", "dentro", "passado", 
            "futuro", "agora", "corpo", "mente", "algoritmo", "sonhos"
        ];

        // ===========================================
        // VARIÁVEIS DO MODO VIDEO
        // ===========================================
        let video;
        let videoPlaying = false;
        let videoLoaded = false;
        
        // ===========================================
        // VARIÁVEIS DO MODO TEXTOS
        // ===========================================
        const shortTexts = [
            `espectralismo:
/
política de arquivo 
(memória coletiva / compartilhada)
< reinventar o passado histórico / arquivado
> produzir futuros
~ sensorialização dos sinais dos tempos compostos
/
/
sonhos:
/
política de memórias
< reinventar memórias / pontos de 
vi(st/d)a singulares do passado
> produzir futuros
~ sensorialização dos sinais dos tempos compostos`,

            `sonho = espectro?

sonho pertence ao 
conjunto dos espectros?
/
os conjuntos 
"sonho" 
e 
"espectro" 
se intersectam?
/
>> - - - - > sonhar é conjurar espectros?`,

            `[ órgão sensoriais não fisiológicos ]
IAs simulam órgãos sensoriais?
Sonhos simulam órgãos sensoriais?
/
(se) toda percepção está vinculada às especificidades 
(eco)sistêmicas e moleculares:
/
IA 
sistemas virtuais / artificiais / sintéticos?
moléculas de silício / artificiais / sintéticas?
/
Sonho
memórias / Fauna mental
moléculas biológicas`,

            `vestígio: passado no presente
catástrofe: passado caindo sobre o presente
anástrofe: futuro caindo sobre o presente
presságio: futuro no presente`,

            `sonho é anastrófico
sonho é presságio de vestígio(s)
/
presságio: futuro no presente
vestígio: passado no presente
/
sonho: passado (memória) montado/editado por futuros?
/
sonho como sensorialização 
dos sinais dos tempos compostos`,

            `o pensamento continua depois 
    da (extinção da) humanidade?
/
o sonho continua depois 
da (extinção da) humanidade?`
        ];
        
        let currentTextIndex = 0;
        let textBackgroundColor;
        let textFontColor;
        let textSizeCalculated = 14;
        let textLines = [];
        
        // ===========================================
        // VARIÁVEIS DO SISTEMA DE ÁUDIO
        // ===========================================
        let sounds = [];
        let soundFiles = [];
        let currentSoundIndex = -1;
        let soundPlaying = false;
        let audioVolume = 1.0;
        let ambientSound;
        let ambientVolume = 0;
        let soundsLoaded = 0;
        let totalSounds = 0;

        // Preencher array com nomes dos arquivos (1.wav a 102.wav)
        for (let i = 1; i <= 102; i++) {
            soundFiles.push(`${i}.wav`);
        }
        totalSounds = soundFiles.length + 1; // +1 para som ambiente

        // ===========================================
        // FUNÇÕES DE DEBUG
        // ===========================================
        function updateDebugInfo(info) {
            const debugDiv = document.getElementById('debugInfo');
            if (debugDiv) {
                debugDiv.textContent = `Debug: ${info}`;
            }
            console.log(`Debug: ${info}`);
        }

        // ===========================================
        // SETUP PRINCIPAL COM CARREGAMENTO ASSÍNCRONO
        // ===========================================
        function preload() {
            console.log('Iniciando preload...');
            updateLoadingScreen();
            
            // Carregar imagens para o modo slideshow (de forma mais robusta)
            let imagePromises = [];
            for (let i = 0; i < imageFiles.length; i++) {
                const imagePromise = new Promise((resolve, reject) => {
                    loadImage(imageFiles[i], 
                        (img) => {
                            loadedImages[i] = img;
                            imagesLoaded++;
                            console.log(`Imagem ${i+1} carregada: ${imageFiles[i]}`);
                            updateLoadingScreen();
                            resolve();
                        },
                        (err) => {
                            console.warn(`Erro ao carregar: ${imageFiles[i]}`, err);
                            imageLoadErrors++;
                            imagesLoaded++;
                            updateLoadingScreen();
                            resolve(); // Resolve mesmo com erro para não travar
                        }
                    );
                });
                imagePromises.push(imagePromise);
            }
            
            // Carregar vídeo (opcional)
            try {
                video = createVideo(['out.mp4'], () => {
                    console.log('Vídeo carregado');
                    videoLoaded = true;
                    video.volume(0);
                    video.speed(0.9);
                    video.hide();
                });
                video.oncanplay = () => {
                    videoLoaded = true;
                    console.log('Vídeo pronto para reproduzir');
                };
            } catch (err) {
                console.warn('Erro ao carregar vídeo:', err);
                showError('Vídeo não disponível');
            }

            // Carregar sons (opcional)
            for (let i = 0; i < soundFiles.length; i++) {
                try {
                    sounds[i] = loadSound(soundFiles[i], 
                        () => {
                            console.log(`Áudio ${i+1} carregado`);
                            soundsLoaded++;
                            updateLoadingScreen();
                        },
                        () => {
                            console.warn(`Erro ao carregar áudio ${i+1}`);
                            soundsLoaded++;
                            updateLoadingScreen();
                        }
                    );
                } catch (err) {
                    console.warn(`Erro ao tentar carregar áudio ${i+1}:`, err);
                    soundsLoaded++;
                }
            }

            // Carregar som ambiente (opcional)
            try {
                ambientSound = loadSound('som.wav', 
                    () => {
                        console.log('Som ambiente carregado');
                        soundsLoaded++;
                        updateLoadingScreen();
                    },
                    () => {
                        console.warn('Erro ao carregar som ambiente');
                        soundsLoaded++;
                        updateLoadingScreen();
                    }
                );
            } catch (err) {
                console.warn('Erro ao tentar carregar som ambiente:', err);
                soundsLoaded++;
            }
        }
        
        function setup() {
            console.log('Iniciando setup...');
            
            canvasWidth = windowWidth;
            canvasHeight = windowHeight;
            createCanvas(canvasWidth, canvasHeight);
            
            // Criar array de imagens na ordem correta
            images = [];
            for (let i = 0; i < imageFiles.length; i++) {
                if (loadedImages[i]) {
                    images.push(loadedImages[i]);
                }
            }
            
            console.log(`Total de imagens carregadas: ${images.length} de ${totalImages}`);
            updateDebugInfo(`Setup: ${images.length} imagens prontas, ${imageLoadErrors} erros`);
            
            // Detectar mobile
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                      ('ontouchstart' in window) || 
                      (navigator.maxTouchPoints > 0);
            
            // Inicializar posição virtual
            virtualMouseX = canvasWidth / 2;
            virtualMouseY = canvasHeight / 2;
            targetX = random(0, canvasWidth);
            targetY = random(0, canvasHeight);
            
            // Sempre inicializar modo palavras (garantido funcionar)
            initializePalavras();
            
            // Tentar inicializar slideshow se houver imagens
            if (images.length > 0) {
                initializeSlideshow();
            } else {
                showError('Nenhuma imagem foi carregada - slideshow indisponível');
            }
            
            updateModeIndicator();

            // Inicializar som ambiente se disponível
            if (ambientSound) {
                try {
                    ambientSound.loop();
                    ambientSound.setVolume(0);
                } catch (err) {
                    console.warn('Erro ao inicializar som ambiente:', err);
                }
            }
            
            loadingComplete = true;
            updateLoadingScreen();
            
            // Esconder tela de carregamento após um pequeno delay
            setTimeout(() => {
                hideLoadingScreen();
                updateDebugInfo('Setup completo - aplicação rodando');
            }, 1000);
        }

        // ===========================================
        // FUNÇÕES DO MODO SLIDESHOW
        // ===========================================
        function initializeSlideshow() {
            updateDebugInfo(`Inicializando slideshow com ${images.length} imagens`);
            if (images.length > 0) {
                loadNewRandomCrop();
                scheduleNextChange();
            } else {
                console.log("Nenhuma imagem foi carregada!");
                updateDebugInfo("ERRO: Nenhuma imagem carregada!");
            }
        }
        
        function loadNewRandomCrop() {
            if (images.length === 0) {
                console.log("Array de imagens está vazio!");
                updateDebugInfo("ERRO: Array de imagens vazio!");
                return;
            }
            
            const randomIndex = Math.floor(Math.random() * images.length);
            currentImage = images[randomIndex];
            console.log(`Selecionada imagem ${randomIndex + 1} de ${images.length}`);
            updateDebugInfo(`Slideshow: imagem ${randomIndex + 1}/${images.length}`);
            generateRandomCrop();
        }
        
        function generateRandomCrop() {
            if (!currentImage) {
                updateDebugInfo("ERRO: Sem imagem atual");
                return;
            }
            
            const imgW = currentImage.width;
            const imgH = currentImage.height;
            
            if (imgW === 0 || imgH === 0) {
                updateDebugInfo("ERRO: Imagem com dimensões inválidas");
                return;
            }
            
            const canvasRatio = width / height;
            const imageRatio = imgW / imgH;
            
            const minSize = 0.50;
            const maxSize = 0.90;
            
            let cropW, cropH;
            
            if (canvasRatio > imageRatio) {
                cropW = imgW * (minSize + Math.random() * (maxSize - minSize));
                cropH = cropW / canvasRatio;
                
                if (cropH > imgH) {
                    cropH = imgH * (minSize + Math.random() * (maxSize - minSize));
                    cropW = cropH * canvasRatio;
                }
            } else {
                cropH = imgH * (minSize + Math.random() * (maxSize - minSize));
                cropW = cropH * canvasRatio;
                
                if (cropW > imgW) {
                    cropW = imgW * (minSize + Math.random() * (maxSize - minSize));
                    cropH = cropW / canvasRatio;
                }
            }
            
            const maxX = imgW - cropW;
            const maxY = imgH - cropH;
            const cropX = Math.random() * maxX;
            const cropY = Math.random() * maxY;
            
            currentCrop = {
                x: cropX,
                y: cropY,
                w: cropW,
                h: cropH
            };
            
            console.log(`Crop gerado: ${Math.round(cropW)}x${Math.round(cropH)} em ${Math.round(cropX)},${Math.round(cropY)}`);
        }
        
        function scheduleNextChange() {
            const nextInterval = 3000 + Math.random() * 7000;
            nextChangeTime = millis() + nextInterval;
        }

        // ===========================================
        // FUNÇÕES DO MODO PALAVRAS
        // ===========================================
        function initializePalavras() {
            conceptBoxes = [];
            
            let centerConceptIndex = allConcepts.indexOf("sonhos");
            let centerConceptText = allConcepts[centerConceptIndex];
            
            centerBox = {
                text: centerConceptText,
                textSize: 14,
                padding: 12,
                cornerRadius: 8
            };
            
            let initialMarginX = canvasWidth * 0.05;
            let initialMarginY = canvasHeight * 0.05;
            
            for (let i = 0; i < allConcepts.length; i++) {
                if (i !== centerConceptIndex) {
                    conceptBoxes.push(createConceptBox(allConcepts[i], initialMarginX, initialMarginY));
                }
            }
            
            updateDebugInfo(`Palavras: ${conceptBoxes.length} conceitos criados`);
        }

        function createConceptBox(conceptText, marginX, marginY) {
            return {
                x: random(marginX, canvasWidth - marginX),
                y: random(marginY, canvasHeight - marginY),
                text: conceptText,
                
                offsetX: random(-50, 50),
                offsetY: random(-50, 50),
                attractionSpeed: random(0.007, 0.23),
                offsetChangeInterval: random(5, 10) * 1000,
                lastOffsetChange: millis(),
                intervalChangeTime: random(1, 5) * 1000,
                lastIntervalChange: millis(),
                
                followOffsetX: random(-100, 100),
                followOffsetY: random(-100, 100),
                followSpeed: random(0.01, 0.1),
                followOffsetChangeInterval: random(5, 10) * 1000,
                lastFollowOffsetChange: millis(),
                followIntervalChangeTime: random(1, 5) * 1000,
                lastFollowIntervalChange: millis(),
                
                textSize: 14,
                padding: 12,
                cornerRadius: 8
            };
        }

        function rotateCenterConcept() {
            let currentCenterText = centerBox.text;
            let referenceX = isMobile ? virtualMouseX : mouseX;
            let referenceY = isMobile ? virtualMouseY : mouseY;
            
            let returnedConcept = createConceptBox(currentCenterText, canvasWidth * 0.05, canvasHeight * 0.05);
            
            let angle = random(TWO_PI);
            let distance = random(50, 150);
            returnedConcept.x = referenceX + cos(angle) * distance;
            returnedConcept.y = referenceY + sin(angle) * distance;
            
            returnedConcept.x = constrain(returnedConcept.x, canvasWidth * 0.05, canvasWidth * 0.95);
            returnedConcept.y = constrain(returnedConcept.y, canvasHeight * 0.05, canvasHeight * 0.95);
            
            conceptBoxes.push(returnedConcept);
            
            let randomIndex = Math.floor(random(conceptBoxes.length));
            let newCenterConcept = conceptBoxes[randomIndex];
            
            centerBox.text = newCenterConcept.text;
            conceptBoxes.splice(randomIndex, 1);
        }

        function disperseBoxes() {
            let referenceX = isMobile ? virtualMouseX : mouseX;
            let referenceY = isMobile ? virtualMouseY : mouseY;
            
            for (let concept of conceptBoxes) {
                let distance = dist(concept.x, concept.y, referenceX, referenceY);
                
                if (distance <= 150) {
                    let angle = atan2(concept.y - referenceY, concept.x - referenceX);
                    
                    if (distance < 155) {
                        angle = random(TWO_PI);
                    }
                    
                    let newX = referenceX + cos(angle) * 200;
                    let newY = referenceY + sin(angle) * 200;
                    
                    let margin = 50;
                    newX = constrain(newX, margin, canvasWidth - margin);
                    newY = constrain(newY, margin, canvasHeight - margin);
                    
                    concept.x = newX;
                    concept.y = newY;
                    
                    concept.offsetX = newX - referenceX;
                    concept.offsetY = newY - referenceY;
                    concept.followOffsetX = newX - referenceX;
                    concept.followOffsetY = newY - referenceY;
                    
                    let currentTime = millis();
                    concept.lastOffsetChange = currentTime;
                    concept.lastIntervalChange = currentTime;
                    concept.lastFollowOffsetChange = currentTime;
                    concept.lastFollowIntervalChange = currentTime;
                }
            }
        }

        function updateVirtualMouse() {
            let currentTime = millis();
            
            if (currentTime - lastSpeedChange >= speedChangeInterval) {
                targetSpeed = random(0.001, 0.004);
                lastSpeedChange = currentTime;
                speedChangeInterval = random(3000, 8000);
            }
            
            currentSpeed = lerp(currentSpeed, targetSpeed, 0.03);
            wanderAngle += random(-wanderSpeed, wanderSpeed);
            
            let distanceToTarget = dist(virtualMouseX, virtualMouseY, targetX, targetY);
            let targetInfluence = map(distanceToTarget, 0, 300, 0.0005, 0.004);
            
            let moveX = cos(wanderAngle) * (currentSpeed * 800) + (targetX - virtualMouseX) * targetInfluence;
            let moveY = sin(wanderAngle) * (currentSpeed * 800) + (targetY - virtualMouseY) * targetInfluence;
            
            let newX = virtualMouseX + moveX;
            let newY = virtualMouseY + moveY;
            
            newX = constrain(newX, 0, canvasWidth);
            newY = constrain(newY, 0, canvasHeight);
            
            if (newX <= 0 || newX >= canvasWidth || 
                newY <= 0 || newY >= canvasHeight) {
                let centerX = canvasWidth * 0.5;
                let centerY = canvasHeight * 0.5;
                targetX = random(centerX - 100, centerX + 100);
                targetY = random(centerY - 100, centerY + 100);
                wanderAngle = random(TWO_PI);
            }
            
            virtualMouseX = newX;
            virtualMouseY = newY;
            
            if (distanceToTarget < 60) {
                targetX = random(0, canvasWidth);
                targetY = random(0, canvasHeight);
            }
            
            if (random() < 0.0008) {
                targetX = random(0, canvasWidth);
                targetY = random(0, canvasHeight);
            }
        }

        function updateModeSystem() {
            let currentTime = millis();
            
            if (currentTime - lastModeChange >= modeChangeInterval && !isTransitioning) {
                isTransitioning = true;
                transitionStartTime = currentTime;
                
                let referenceX = isMobile ? virtualMouseX : mouseX;
                let referenceY = isMobile ? virtualMouseY : mouseY;
                
                if (currentMode === 'attraction') {
                    currentMode = 'following';
                    modeChangeInterval = random(7000, 21000);
                    
                    for (let concept of conceptBoxes) {
                        concept.followOffsetX = concept.x - referenceX;
                        concept.followOffsetY = concept.y - referenceY;
                        
                        let distance = sqrt(concept.followOffsetX * concept.followOffsetX + concept.followOffsetY * concept.followOffsetY);
                        if (distance < 25) {
                            let angle = atan2(concept.followOffsetY, concept.followOffsetX);
                            concept.followOffsetX = cos(angle) * 25;
                            concept.followOffsetY = sin(angle) * 25;
                        }
                        
                        concept.lastFollowOffsetChange = currentTime;
                        concept.lastFollowIntervalChange = currentTime;
                    }
                } else {
                    currentMode = 'attraction';
                    modeChangeInterval = random(7000, 37000);
                    
                    for (let concept of conceptBoxes) {
                        concept.offsetX = concept.x - referenceX;
                        concept.offsetY = concept.y - referenceY;
                        
                        concept.lastOffsetChange = currentTime;
                        concept.lastIntervalChange = currentTime;
                    }
                }
                
                lastModeChange = currentTime;
            }
            
            if (isTransitioning && currentTime - transitionStartTime >= transitionDuration) {
                isTransitioning = false;
            }
        }

        function updateAttractionMode(concept, referenceX, referenceY, currentTime) {
            if (currentTime - concept.lastIntervalChange >= concept.intervalChangeTime) {
                concept.offsetChangeInterval = random(5, 10) * 1000;
                concept.lastIntervalChange = currentTime;
                concept.intervalChangeTime = random(1, 10) * 1000;
            }
            
            if (!isTransitioning && currentTime - concept.lastOffsetChange >= concept.offsetChangeInterval) {
                let marginX = canvasWidth * 0.05;
                let marginY = canvasHeight * 0.05;
                
                let targetX = random(marginX, canvasWidth - marginX);
                let targetY = random(marginY, canvasHeight - marginY);
                
                concept.offsetX = targetX - referenceX;
                concept.offsetY = targetY - referenceY;
                
                concept.x = targetX;
                concept.y = targetY;
                
                concept.lastOffsetChange = currentTime;
            }
            
            let distanceFromReference = dist(concept.x, concept.y, referenceX, referenceY);
            
            if (distanceFromReference <= RanDist) {
                concept.x = lerp(concept.x, referenceX, concept.attractionSpeed);
                concept.y = lerp(concept.y, referenceY, concept.attractionSpeed);
            }
        }

        function updateFollowingMode(concept, referenceX, referenceY, currentTime) {
            if (currentTime - concept.lastFollowIntervalChange >= concept.followIntervalChangeTime) {
                concept.followOffsetChangeInterval = random(5, 10) * 1000;
                concept.lastFollowIntervalChange = currentTime;
                concept.followIntervalChangeTime = random(1, 5) * 1000;
            }
            
            if (currentTime - concept.lastFollowOffsetChange >= concept.followOffsetChangeInterval) {
                let newOffsetX, newOffsetY, distance;
                let attempts = 0;
                
                do {
                    if (random() < 0.7) {
                        let angle = random(TWO_PI);
                        let radius = random(30, 150);
                        newOffsetX = cos(angle) * radius;
                        newOffsetY = sin(angle) * radius;
                    } else {
                        let angle = random(TWO_PI);
                        let maxRadius = min(
                            sqrt(referenceX * referenceX + referenceY * referenceY),
                            sqrt((canvasWidth - referenceX) * (canvasWidth - referenceX) + referenceY * referenceY),
                            sqrt(referenceX * referenceX + (canvasHeight - referenceY) * (canvasHeight - referenceY)),
                            sqrt((canvasWidth - referenceX) * (canvasWidth - referenceX) + (canvasHeight - referenceY) * (canvasHeight - referenceY))
                        );
                        let radius = random(25, maxRadius);
                        newOffsetX = cos(angle) * radius;
                        newOffsetY = sin(angle) * radius;
                    }
                    
                    let targetX = referenceX + newOffsetX;
                    let targetY = referenceY + newOffsetY;
                    
                    if (targetX < 0) newOffsetX = -referenceX + 5;
                    if (targetX > canvasWidth) newOffsetX = canvasWidth - referenceX - 5;
                    if (targetY < 0) newOffsetY = -referenceY + 5;
                    if (targetY > canvasHeight) newOffsetY = canvasHeight - referenceY - 5;
                    
                    distance = sqrt(newOffsetX * newOffsetX + newOffsetY * newOffsetY);
                    attempts++;
                    
                    if (attempts > 50) {
                        let angle = random(TWO_PI);
                        newOffsetX = cos(angle) * 80;
                        newOffsetY = sin(angle) * 80;
                        distance = 80;
                    }
                } while (distance < 25 && attempts < 50);
                
                concept.followOffsetX = newOffsetX;
                concept.followOffsetY = newOffsetY;
                
                concept.x = referenceX + concept.followOffsetX;
                concept.y = referenceY + concept.followOffsetY;
                
                concept.lastFollowOffsetChange = currentTime;
            }
            
            let targetX = referenceX + concept.followOffsetX;
            let targetY = referenceY + concept.followOffsetY;
            
            let distanceToMouse = dist(targetX, targetY, referenceX, referenceY);
            
            if (distanceToMouse < 25) {
                let angle = atan2(targetY - referenceY, targetX - referenceX);
                targetX = referenceX + cos(angle) * 25;
                targetY = referenceY + sin(angle) * 25;
            }
            
            concept.x = lerp(concept.x, targetX, concept.followSpeed);
            concept.y = lerp(concept.y, targetY, concept.followSpeed);
        }

        function drawConceptBox(box, x, y) {
            push();
            textSize(box.textSize);
            textFont('Courier New');
            
            let textW = textWidth(box.text);
            let boxWidth = textW + box.padding * 2;
            let boxHeight = box.textSize + box.padding * 2;
            
            stroke(255);
            strokeWeight(1);
            noFill();
            rect(x - boxWidth/2, y - boxHeight/2, boxWidth, boxHeight, box.cornerRadius);
            
            fill(255);
            noStroke();
            textAlign(CENTER, CENTER);
            text(box.text, x, y);
            pop();
        }

        // ===========================================
        // FUNÇÕES DO MODO VIDEO
        // ===========================================
        function initializeVideo() {
            if (video && videoLoaded) {
                video.loop();
                video.speed(0.9);
                videoPlaying = true;
                console.log("Modo VIDEO iniciado");
                updateDebugInfo("Video: reproduzindo");
            } else {
                console.log("Vídeo não carregado!");
                updateDebugInfo("ERRO: Vídeo não carregado");
                // Fallback para modo palavras se o vídeo não funcionar
                currentAppMode = 'palavras';
                updateModeIndicator();
            }
        }

        // ===========================================
        // FUNÇÕES DO MODO TEXTOS
        // ===========================================
        function initializeTextos() {
            // Escolher um texto aleatório
            currentTextIndex = floor(random(shortTexts.length));
            
            // Escolher cores aleatórias
            textBackgroundColor = color(random(255), random(255), random(255));
            textFontColor = color(random(255), random(255), random(255));
            
            // Processar o texto em linhas
            processTextLines();
            
            console.log("Modo TEXTOS iniciado");
            updateDebugInfo(`Textos: texto ${currentTextIndex + 1}/${shortTexts.length}`);
        }
        
        function processTextLines() {
            let currentText = shortTexts[currentTextIndex];
            
            // Processamento especial para manter a estrutura poética
            textLines = [];
            let rawLines = currentText.split('\n');
            
            for (let line of rawLines) {
                if (line.trim() === '/') {
                    // Linha vazia (pula linha)
                    textLines.push(' '); // Espaço vazio mantém o espaçamento
                } else if (line.trim() === '//') {
                    // Dupla linha vazia
                    textLines.push(' ');
                    textLines.push(' ');
                } else {
                    // Linha normal
                    textLines.push(line.trim());
                }
            }
            
            calculateTextSize();
        }
                
        function calculateTextSize() {
            const MIN_FONT_SIZE = 32;
            const MAX_FONT_SIZE = 200;
            const TARGET_OCCUPANCY = 0.85;
            
            push();
            textFont('Courier New');
            
            // Medir a linha mais larga
            let maxLineWidth = 0;
            textSize(100);
            for (let line of textLines) {
                maxLineWidth = max(maxLineWidth, textWidth(line));
            }
            
            // Calcular tamanho base
            let fontSize = min(
                (width * 0.7) / (maxLineWidth / 100),
                (height * 0.7) / (textLines.length * 1.3)
            );
            
            // Ajuste agressivo para ocupar mais espaço
            fontSize = min(fontSize * 1.15, MAX_FONT_SIZE);
            fontSize = max(fontSize, MIN_FONT_SIZE);
            
            textSizeCalculated = fontSize;
            pop();
            
            console.log(`Tamanho da fonte calculado: ${textSizeCalculated}px`);
        }

        function drawTextos() {
            // Fundo com cor aleatória (mantendo contraste)
            background(textBackgroundColor);
            
            // Configurações de texto
            push();
            fill(textFontColor);
            noStroke();
            textFont('Courier New');
            textSize(textSizeCalculated);
            textAlign(CENTER, CENTER);
            
            // Calcular altura total do bloco de texto
            const lineHeight = textSizeCalculated * 1.3;
            const totalTextHeight = textLines.length * lineHeight;
            
            // Posição inicial Y (centralizado verticalmente)
            let yPos = (height - totalTextHeight) / 2 + textSizeCalculated/2;
            
            // Desenhar cada linha
            for (let line of textLines) {
                text(line, width/2, yPos);
                yPos += lineHeight;
            }
            
            pop();
        }

        // ===========================================
        // FUNÇÕES DO SISTEMA DE ÁUDIO
        // ===========================================
        function playRandomSound() {
            if (sounds.length === 0) {
                console.warn('Nenhum som disponível');
                return;
            }
            
            // Para o som atual se estiver tocando
            if (soundPlaying && currentSoundIndex >= 0 && sounds[currentSoundIndex]) {
                try {
                    sounds[currentSoundIndex].stop();
                } catch (err) {
                    console.warn('Erro ao parar som:', err);
                }
            }
            
            // Seleciona um novo som aleatório (diferente do atual)
            let newIndex;
            do {
                newIndex = floor(random(sounds.length));
            } while (newIndex === currentSoundIndex && sounds.length > 1);
            
            // Verificar se o som existe
            if (!sounds[newIndex]) {
                console.warn(`Som ${newIndex} não existe`);
                return;
            }
            
            try {
                currentSoundIndex = newIndex;
                sounds[currentSoundIndex].rate(0.95);
                sounds[currentSoundIndex].play();
                sounds[currentSoundIndex].setVolume(audioVolume);
                soundPlaying = true;
                
                // Quando terminar, toca o próximo
                sounds[currentSoundIndex].onended(() => {
                    soundPlaying = false;
                    playRandomSound();
                });
            } catch (err) {
                console.warn('Erro ao reproduzir som:', err);
                soundPlaying = false;
            }
        }

        function drawVideo() {
            if (!video || !videoPlaying || !videoLoaded) return;
            
            try {
                // Calcular dimensões mantendo proporção 16:9
                let videoRatio = 16 / 9;
                let canvasRatio = width / height;
                
                let drawWidth, drawHeight;
                let offsetX = 0, offsetY = 0;
                
                if (canvasRatio > videoRatio) {
                    // Canvas mais largo que o vídeo
                    drawHeight = height;
                    drawWidth = drawHeight * videoRatio;
                    offsetX = (width - drawWidth) / 2;
                } else {
                    // Canvas mais alto que o vídeo
                    drawWidth = width;
                    drawHeight = drawWidth / videoRatio;
                    offsetY = (height - drawHeight) / 2;
                }
                
                image(video, offsetX, offsetY, drawWidth, drawHeight);
            } catch (err) {
                console.warn('Erro ao desenhar vídeo:', err);
                // Fallback para outro modo se o vídeo falhar
                currentAppMode = 'palavras';
                updateModeIndicator();
            }
        }

        // ===========================================
        // ALTERNÂNCIA DE MODOS E CONTROLES
        // ===========================================
        function switchMode() {
            const availableModes = [];
            
            // Adicionar modos disponíveis baseado no que foi carregado
            availableModes.push('palavras'); // Sempre disponível
            availableModes.push('textos'); // Sempre disponível
            
            if (images.length > 0) {
                availableModes.push('slideshow');
            }
            
            if (videoLoaded) {
                availableModes.push('video');
            }
            
            // Selecionar um modo aleatório diferente do atual
            let newMode;
            do {
                newMode = random(availableModes);
            } while (availableModes.length > 1 && newMode === currentAppMode);
            
            currentAppMode = newMode;
            
            // Inicializar o novo modo
            switch(currentAppMode) {
                case 'slideshow':
                    if (images.length > 0) {
                        loadNewRandomCrop();
                        scheduleNextChange();
                    }
                    if (videoPlaying) {
                        try {
                            video.pause();
                            videoPlaying = false;
                        } catch (err) {
                            console.warn('Erro ao pausar vídeo:', err);
                        }
                    }
                    updateDebugInfo(`Mudou para SLIDESHOW (${images.length} imagens)`);
                    break;
                    
                case 'palavras':
                    if (videoPlaying) {
                        try {
                            video.pause();
                            videoPlaying = false;
                        } catch (err) {
                            console.warn('Erro ao pausar vídeo:', err);
                        }
                    }
                    updateDebugInfo(`Mudou para PALAVRAS (${conceptBoxes.length} conceitos)`);
                    break;
                    
                case 'video':
                    initializeVideo();
                    break;
                    
                case 'textos':
                    if (videoPlaying) {
                        try {
                            video.pause();
                            videoPlaying = false;
                        } catch (err) {
                            console.warn('Erro ao pausar vídeo:', err);
                        }
                    }
                    initializeTextos();
                    break;
            }
            
            console.log(`Mudou para modo ${currentAppMode.toUpperCase()}`);
            updateModeIndicator();
        }
        
        function updateModeIndicator() {
            const indicator = document.getElementById('modeIndicator');
            const indicator2 = document.getElementById('modeIndicator2');
            const indicator3 = document.getElementById('modeIndicator3');
            
            if (indicator2) indicator2.textContent = '[sonhos] > S / M';
            if (indicator3) indicator3.textContent = '[sons] > A';
            
            if (indicator) {
                if (currentAppMode === 'slideshow') {
                    indicator.textContent = '[caderno / diagramas] > X <';
                } else if (currentAppMode === 'palavras') {
                    indicator.textContent = '[palavras] > X <';
                } else if (currentAppMode === 'video') {
                    indicator.textContent = '[vídeo] > X <';
                } else {
                    indicator.textContent = '[textos] > X <';
                }
            }
        }

        // ===========================================
        // DRAW PRINCIPAL
        // ===========================================
        function draw() {
            try {
                if (currentAppMode === 'slideshow') {
                    // MODO SLIDESHOW
                    background(0);
                    
                    if (millis() > nextChangeTime && images.length > 0) {
                        loadNewRandomCrop();
                        scheduleNextChange();
                    }
                    
                    if (currentImage && currentCrop) {
                        // Verificar se as dimensões são válidas
                        if (currentCrop.w > 0 && currentCrop.h > 0) {
                            image(currentImage, 
                                0, 0, width, height,
                                currentCrop.x, currentCrop.y, currentCrop.w, currentCrop.h
                            );
                        }
                    }
                    
                } else if (currentAppMode === 'palavras') {
                    // MODO PALAVRAS
                    background(26, 26, 46);
                    
                    let currentTime = millis();
                    
                    updateModeSystem();
                    
                    if (isMobile) {
                        updateVirtualMouse();
                    }
                    
                    let referenceX = isMobile ? virtualMouseX : mouseX;
                    let referenceY = isMobile ? virtualMouseY : mouseY;
                    
                    if (currentMode === 'attraction' && currentTime - lastRanDistChange >= ranDistChangeInterval) {
                        let randx = random();
                        if (randx < 0.15) {
                            RanDist = Math.round(random(33, 333));
                        } else {
                            RanDist = Math.round(random(33, 88));
                        }
                        lastRanDistChange = currentTime;
                        ranDistChangeInterval = random(1000, 13000);
                    }
                    
                    for (let concept of conceptBoxes) {
                        if (currentMode === 'attraction') {
                            updateAttractionMode(concept, referenceX, referenceY, currentTime);
                        } else {
                            updateFollowingMode(concept, referenceX, referenceY, currentTime);
                        }
                        
                        drawConceptBox(concept, concept.x, concept.y);
                    }
                    
                    drawConceptBox(centerBox, referenceX, referenceY);
                    
                } else if (currentAppMode === 'video') {
                    // MODO VIDEO
                    background(0);
                    drawVideo();
                    
                } else if (currentAppMode === 'textos') {
                    // MODO TEXTOS
                    drawTextos();
                }
            } catch (error) {
                console.error('Erro no draw:', error);
                updateDebugInfo(`ERRO: ${error.message}`);
                // Fallback para modo palavras em caso de erro
                currentAppMode = 'palavras';
                updateModeIndicator();
            }
        }

        // ===========================================
        // EVENTOS DE CONTROLE
        // ===========================================
        function keyPressed() {
            if (key === 'x' || key === 'X') {
                switchMode();
            }
            
            if (key === 's' || key === 'S') {
                if (soundPlaying) {
                    // Se já está tocando, para a reprodução
                    if (currentSoundIndex >= 0 && sounds[currentSoundIndex]) {
                        try {
                            sounds[currentSoundIndex].stop();
                            soundPlaying = false;
                        } catch (err) {
                            console.warn('Erro ao parar som:', err);
                        }
                    }
                } else {
                    // Começa a sequência aleatória
                    playRandomSound();
                }
            }

            if (key === 'm' || key === 'M') {
                audioVolume = audioVolume === 0 ? 1.1 : 0;
                if (soundPlaying && currentSoundIndex >= 0 && sounds[currentSoundIndex]) {
                    try {
                        sounds[currentSoundIndex].setVolume(audioVolume);
                    } catch (err) {
                        console.warn('Erro ao ajustar volume:', err);
                    }
                }
            }

            if (key === 'a' || key === 'A') {
                ambientVolume = ambientVolume === 0 ? 0.25 : 0;
                if (ambientSound) {
                    try {
                        ambientSound.setVolume(ambientVolume);
                    } catch (err) {
                        console.warn('Erro ao ajustar volume ambiente:', err);
                    }
                }
            }
        }
        
        function mousePressed() {
            if (currentAppMode === 'palavras') {
                if (mouseButton === LEFT) {
                    rotateCenterConcept();
                    
                    if (!isMobile) {
                        for (let concept of conceptBoxes) {
                            concept.lastOffsetChange = millis();
                            concept.lastIntervalChange = millis();
                            concept.lastFollowOffsetChange = millis();
                            concept.lastFollowIntervalChange = millis();
                        }
                    }
                } else if (mouseButton === RIGHT) {
                    disperseBoxes();
                    return false;
                }
            }
        }
        
        function touchStarted() {
            if (currentAppMode === 'palavras') {
                rotateCenterConcept();
            }
            return false;
        }
        
        function windowResized() {
            canvasWidth = windowWidth;
            canvasHeight = windowHeight;
            resizeCanvas(canvasWidth, canvasHeight);
            
            if (isMobile) {
                targetX = constrain(targetX, 0, canvasWidth);
                targetY = constrain(targetY, 0, canvasHeight);
            }
            
            if (currentAppMode === 'slideshow' && currentImage) {
                generateRandomCrop();
            } else if (currentAppMode === 'textos') {
                calculateTextSize();
            }
        }
        
        // Prevenir menu de contexto
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });

        // ===========================================
        // INICIALIZAÇÃO ADICIONAL PARA COMPATIBILIDADE
        // ===========================================
        
        // Adicionar event listeners para garantir que funcione em diferentes navegadores
        window.addEventListener('load', function() {
            console.log('Window loaded - verificando se p5.js está rodando...');
            setTimeout(() => {
                if (!loadingComplete) {
                    console.warn('Carregamento demorou mais que esperado');
                    showError('Carregamento lento - alguns recursos podem não estar disponíveis');
                }
            }, 10000);
        });

        // Verificação de compatibilidade do navegador
        function checkBrowserCompatibility() {
            const isCompatible = !!(window.WebGLRenderingContext || window.WebGL2RenderingContext);
            if (!isCompatible) {
                showError('WebGL não suportado - funcionalidade limitada');
            }
            return isCompatible;
        }

        // Chamar verificação
        checkBrowserCompatibility();
    </script>
</body>
</html>
